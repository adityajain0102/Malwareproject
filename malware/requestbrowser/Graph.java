package com.malware.requestbrowser;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.geom.Point2D;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.Vector;

import javax.swing.JPanel;

import com.malware.bean.ENBAxisBean;
import com.malware.bean.MapCooridnates;
import com.malware.bean.RNAxisBean;
import com.malware.bean.UEAxisBean;

public class Graph extends JPanel {

	static int N,uenodes,rnnodes,enbNodes;
	String path = null;
	boolean move = true;
	int points[][];
	int edge[][];
	int d[];
	Random rand = new Random(1000);
	int k = 0;
	Set set = new HashSet<String>();
	Map treemap;
	int unauth = 0;
	boolean authflag = true;

	// Graph constructor take the N nodes of x and y coordinates
	// and its directions using random number generation
	public Graph(int uenodes,int rnnodes,int enbNodes) {
		 this.uenodes = uenodes;
		 this.rnnodes = rnnodes;
		 this.enbNodes = enbNodes;
	}

	// this Algorithm is used to find the path between src to dest
	// It returns all nodes in the path from source to destination
	// each node name length is tacken as 2 chars lenth
	public String path(int src, int dest, String p) {
		if (src == dest)
			return p;
		if (edge[src][dest] == 1)
			return p + node(dest);

		String path = null;
		for (int i = 0; i < N; i++)
			if (edge[src][i] == 1) {
				if (p.indexOf(node(i)) == -1) {
					String newpath = path(i, dest, p + node(i));
					if (newpath != null)
						if (path == null || newpath.length() < path.length()) {
							path = newpath;
							set.add(path);
						}
				}
			}
		if (path != null) {
			String[] nodes = new String[(path.length() - 4) / 2];
			for (int j = 0, k = 0; j < nodes.length; j++) {
				if (k < path.length() - 4) {
					nodes[j] = path.substring(k, k + 2);
					k = k + 2;
				}
			}
			unauth = Integer
					.parseInt(nodes[new Random().nextInt(nodes.length)]);
		}
		return path;
	}

	public Set possiblePath(int src, int dest, String p) {
		String path = null;
		for (int i = 0; i < N; i++)
			if (edge[src][i] == 1) {
				if (p.indexOf(node(i)) == -1) {
					String newpath = path(i, dest, p + node(i));
					if (newpath != null)
						if (path == null || newpath.length() < path.length()) {
							path = newpath;
							set.add(path);
						}
				}
			}

		// System.out.println("set :" + set);
		// System.out.println("set :" + set.size());
		return set;
	}

	public void path1(String p) {

		path = p;
		System.out.println(path);

	}

	// to represent the node no in to string format
	// length represents 2 chars. If length is 1 char it adds 0 as prefix
	String node(int i) {
		if (i > 9)
			return String.valueOf(i);
		else
			return "0" + String.valueOf(i);
	}

	// changes the Node Positions based on directions and calculates the edges
	public void changeNodesPos() {
		for (int i = 0; i < N; i++) {
			int x = 0;
			int y = 0;
			switch (d[i]) {
			case 0:
				x++;
				break;
			case 1:
				x++;
				y--;
				break;
			case 2:
				y--;
				break;
			case 3:
				x--;
				y--;
				break;
			case 4:
				x--;
				break;
			case 5:
				x--;
				y++;
				break;
			case 6:
				y++;
				break;
			case 7:
				x++;
				y++;
				break;
			default:
			}
			points[i][0] += x;
			points[i][1] += y;
			if (points[i][0] < 20 || points[i][0] > 775) {
				d[i] += 4;
				d[i] %= 8;
			}
			if (points[i][1] < 15 || points[i][1] > 385) {
				d[i] += 4;
				d[i] %= 8;
			}
		}

		// sets the edges
		edge = new int[N][N];
		for (int i = 0; i < N; i++)
			for (int j = i + 1; j < N; j++) {
				int dest = (int) (Point2D.distance(points[i][0], points[i][1],
						points[j][0], points[j][1]));
				if (dest < 200)
					edge[i][j] = edge[j][i] = 1;
			}
	}

	// paints the graph if path is existed it draws the path
	public void paint(Graphics g) {
//		if ((path == null) && move)
//			changeNodesPos();
//
//		// clear panel & draw the border
//		g.clearRect(0, 0, 793, 400);
//		g.setColor(new Color(255, 255, 255));
//		g.fillRoundRect(3, 0, 785, 399, 10, 10);
//
//		// Draw Edges
//		g.setColor(Color.black);
//		int totaldist = 0;
//		long minutes = 0;
//		long sec = 0;
//		Date d1 = new Date();
//		long d1time = d1.getTime();
//		for (int i = 0; i < N; i++)
//			for (int j = i + 1; j < N; j++)
//				if (edge[i][j] == 1) {
//					g.drawLine(points[i][0], points[i][1], points[j][0],
//							points[j][1]);
//
//					System.out.println("iiiiiiiii--------" + (i + 1)
//							+ "      jj-------------" + (j + 1)
//							+ " cost between Nodes " + ((j - i) + 10));
//
//					System.out.println("(x1,y1)=(" + points[i][0] + ","
//							+ points[i][1] + ") (x2,y2)=(" + points[j][0] + ","
//							+ points[j][1] + ")");
//
//					int x = (points[i][0] + points[j][0]) / 2;
//					int y = (points[i][1] + points[j][1]) / 2;
//					int z = ((j - i) + 10);
//
//				}
//		g.setFont(new Font("Default", Font.BOLD, 12));
//		for (int i = 0; i < N; i++)
//			drawNode(g, i, Color.white);
//
//		// Draw path between source & destination
//		if (path != null) {
//			int p1, p2 = 0;
//			g.setColor(Color.red);
//			for (int i = 0; i < path.length() - 3; i += 2) {
//				p1 = Integer.parseInt(path.substring(i, i + 2));
//				p2 = Integer.parseInt(path.substring(i + 2, i + 4));
//				g.drawLine(points[p1][0], points[p1][1], points[p2][0],
//						points[p2][1]);
//				drawNode(g, p1, Color.red);
//			}
//			drawNode(g, p2, Color.red);
//			path = null;
//		}
//		
		drawUENodes(g);
		drawURNNodes(g);
		drawUELeftLines(g);
		drawENBNNodes(g);
		drawControllerNNodes(g);
		drawUERightLines(g);
		drawRNLeftLines(g);
		drawRNRightLines(g);
		

		drawStorageRNLeftLines(g);
		drawStorageRNRightLines(g);
		
		
		drawControllerRNLeftLines(g);
		drawControllerRNRightLines(g);
		

		drawControllerStorageRNRightLines(g);
		
		
		
	}
	
	// Display the node Text
	public void drawUENodes(Graphics g) {
		Map<Integer, UEAxisBean> ueMap =  MapCooridnates.uEMapCooridnates();
		for (int j = 0; j < ueMap.size(); j++) {
			System.out.println("hi"+j);
			final String node = "HttpRequest" + (j + 1);
			g.setColor(Color.blue);
//			g.fillOval(ueMap.get(j+1).getxCoordinate(),ueMap.get(j+1).getyCoordinate(), 28, 28);
			Toolkit t = Toolkit.getDefaultToolkit();
			Image img = t.getImage("./images/HttpRequest.PNG");
			g.drawImage(img, ueMap.get(j+1).getxCoordinate(),ueMap.get(j+1).getyCoordinate(), this);
//			g.setColor(c);
			if (j < 9)
				g.drawString(node, ueMap.get(j+1).getxCoordinate(),ueMap.get(j+1).getyCoordinate());
			else
				g.drawString(node, ueMap.get(j+1).getxCoordinate(),ueMap.get(j+1).getyCoordinate());
		}
	}
	
	// Display the node Text
	public void drawUELeftLines(Graphics g) {
		Map<Integer, UEAxisBean> fromCoorinates =  MapCooridnates.uEMapCooridnates();
		Map<Integer, RNAxisBean> toCoordinate =  MapCooridnates.rNMapCooridnates();
		for (int j = 0; j < fromCoorinates.size()/2; j++) {
			for (int i = 0; i < toCoordinate.size()/2; i++) {
				g.drawLine(fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate(),toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate());
			}
		}
	}	
	
	// Display the node Text
	public void drawURNNodes(Graphics g) {

		Map<Integer, RNAxisBean> rnMap =  MapCooridnates.rNMapCooridnates();
		for (int j = 0; j < rnMap.size(); j++) {
			String node = "V-Node" + (j + 1);
			g.setColor(Color.blue);
//			g.fillOval(ueMap.get(j+1).getxCoordinate(),ueMap.get(j+1).getyCoordinate(), 28, 28);
			Toolkit t = Toolkit.getDefaultToolkit();
			Image img = t.getImage("./images/V-Node.PNG");
			g.drawImage(img, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate(), this);
//			g.setColor(c);
			if (j < 9)
				g.drawString(node, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate());
			else
				g.drawString(node, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate());
		}
	}
	
	// Display the node Text
	public void drawENBNNodes(Graphics g) {

		Map<Integer, ENBAxisBean> rnMap =  MapCooridnates.eNBMapCooridnates();
		for (int j = 0; j < rnMap.size(); j++) {
			String node = "StorageServer" + (j + 1);
			g.setColor(Color.blue);
//			g.fillOval(ueMap.get(j+1).getxCoordinate(),ueMap.get(j+1).getyCoordinate(), 28, 28);
			Toolkit t = Toolkit.getDefaultToolkit();
			Image img = t.getImage("./images/StorageServer.PNG");
			g.drawImage(img, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate(), this);
//			g.setColor(c);
			if (j < 9)
				g.drawString(node, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate());
			else
				g.drawString(node, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate());
		}
	}
	
	// Display the node Text
	public void drawControllerNNodes(Graphics g) {

		Map<Integer, ENBAxisBean> rnMap =  MapCooridnates.controllerServerMapCooridnates();
		for (int j = 0; j < rnMap.size(); j++) {
			String node = "ControllerServer" + (j + 1);
			g.setColor(Color.blue);
//			g.fillOval(ueMap.get(j+1).getxCoordinate(),ueMap.get(j+1).getyCoordinate(), 28, 28);
			Toolkit t = Toolkit.getDefaultToolkit();
			Image img = t.getImage("./images/ControllerServer.PNG");
			g.drawImage(img, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate(), this);
//			g.setColor(c);
			if (j < 9)
				g.drawString(node, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate());
			else
				g.drawString(node, rnMap.get(j+1).getxCoordinate(),rnMap.get(j+1).getyCoordinate());
		}
	}
	
	
	// Display the node Text
	public void drawUERightLines(Graphics g) {
		Map<Integer, UEAxisBean> fromCoorinates =  MapCooridnates.uEMapCooridnates();
		Map<Integer, RNAxisBean> toCoordinate =  MapCooridnates.rNMapCooridnates();
		for (int j = fromCoorinates.size()/2; j < fromCoorinates.size(); j++) {
			for (int i = toCoordinate.size()/2; i < toCoordinate.size(); i++) {
				g.drawLine(toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate(),fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate());
			}
		}
	}
	
	public void drawRNLeftLines(Graphics g) {
		Map<Integer, RNAxisBean> fromCoorinates =  MapCooridnates.rNMapCooridnates();
		Map<Integer, RNAxisBean> toCoordinate =  MapCooridnates.rNMapCooridnates();
		for (int j = 0; j < fromCoorinates.size()/2; j++) {
			for (int i = 0; i < toCoordinate.size(); i++) {
				g.drawLine(fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate(),toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate());
//				System.out.println("("+fromCoorinates.get(j+1).getxCoordinate()+","+fromCoorinates.get(j+1).getyCoordinate()+","+toCoordinate.get(i+1).getxCoordinate()+","+toCoordinate.get(i+1).getyCoordinate()+")");
			}
		}
	}	
	
	public void drawStorageRNLeftLines(Graphics g) {
		Map<Integer, RNAxisBean> fromCoorinates =  MapCooridnates.rNMapCooridnates();
		Map<Integer, ENBAxisBean> toCoordinate =  MapCooridnates.eNBMapCooridnates();
		for (int j = 0; j < fromCoorinates.size()/2; j++) {
			for (int i = 0; i < toCoordinate.size(); i++) {
				g.drawLine(fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate(),toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate());
//				System.out.println("("+fromCoorinates.get(j+1).getxCoordinate()+","+fromCoorinates.get(j+1).getyCoordinate()+","+toCoordinate.get(i+1).getxCoordinate()+","+toCoordinate.get(i+1).getyCoordinate()+")");
			}
		}
	}
	
	public void drawControllerRNLeftLines(Graphics g) {
		Map<Integer, RNAxisBean> fromCoorinates =  MapCooridnates.rNMapCooridnates();
		Map<Integer, ENBAxisBean> toCoordinate =  MapCooridnates.controllerServerMapCooridnates();
		for (int j = 0; j < fromCoorinates.size()/2; j++) {
			for (int i = 0; i < toCoordinate.size(); i++) {
				g.drawLine(fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate(),toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate());
//				System.out.println("("+fromCoorinates.get(j+1).getxCoordinate()+","+fromCoorinates.get(j+1).getyCoordinate()+","+toCoordinate.get(i+1).getxCoordinate()+","+toCoordinate.get(i+1).getyCoordinate()+")");
			}
		}
	}
	
	
	
	// Display the node Text
	public void drawRNRightLines(Graphics g) {
		Map<Integer, RNAxisBean> fromCoorinates =  MapCooridnates.rNMapCooridnates();
		Map<Integer, RNAxisBean> toCoordinate =  MapCooridnates.rNMapCooridnates();
		for (int j = fromCoorinates.size()/2; j < fromCoorinates.size(); j++) {
			for (int i = 0; i < toCoordinate.size(); i++) {
				g.drawLine(toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate(),fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate());
			}
		}
	}
	
	// Display the node Text
	public void drawStorageRNRightLines(Graphics g) {
		Map<Integer, RNAxisBean> fromCoorinates =  MapCooridnates.rNMapCooridnates();
		Map<Integer, ENBAxisBean> toCoordinate =  MapCooridnates.eNBMapCooridnates();
		for (int j = fromCoorinates.size()/2; j < fromCoorinates.size(); j++) {
			for (int i = 0; i < toCoordinate.size(); i++) {
				g.drawLine(toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate(),fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate());
			}
		}
	}
	
	
	// Display the node Text
	public void drawControllerRNRightLines(Graphics g) {
		Map<Integer, RNAxisBean> fromCoorinates =  MapCooridnates.rNMapCooridnates();
		Map<Integer, ENBAxisBean> toCoordinate =  MapCooridnates.controllerServerMapCooridnates();
		for (int j = fromCoorinates.size()/2; j < fromCoorinates.size(); j++) {
			for (int i = 0; i < toCoordinate.size(); i++) {
				g.drawLine(toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate(),fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate());
			}
		}
	}
	
	// Display the node Text
	public void drawControllerStorageRNRightLines(Graphics g) {
		Map<Integer, ENBAxisBean> fromCoorinates =  MapCooridnates.eNBMapCooridnates();
		Map<Integer, ENBAxisBean> toCoordinate =  MapCooridnates.controllerServerMapCooridnates();
		for (int j = fromCoorinates.size()/2; j < fromCoorinates.size(); j++) {
			for (int i = 0; i < toCoordinate.size(); i++) {
				g.drawLine(toCoordinate.get(i+1).getxCoordinate(),toCoordinate.get(i+1).getyCoordinate(),fromCoorinates.get(j+1).getxCoordinate(),fromCoorinates.get(j+1).getyCoordinate());
			}
		}
	}
 
	

	// sets the table data in a vector and calls the RoutingTable as visible
	public void showRoutingTable(int hop) {
		Vector table = new Vector(N);
		for (int j = 0; j < N; j++) {
			Vector row = new Vector(4);
			row.add(" AP" + (j + 1));
			String p = path(hop, j, "");
			if (p == null) {
				row.add(" NONE ");
				row.add(" Infinity");
			} else {
				if (hop == j)
					row.add("  -");
				else
					row.add(" AP" + (Integer.parseInt(p.substring(0, 2)) + 1));
				row.add("  " + String.valueOf(p.length() / 2));
			}
			row.add(" S" + (rand.nextInt(1000)) + "_AP" + (j + 1));
			table.add(row);
		}
//		new RoutingTable(table, "AP" + (hop + 1) + " Routing Table");
	}
}
